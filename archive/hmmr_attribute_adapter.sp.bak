/**
 * Based upon FlamingSarge's "tf2attributes".
 * (https://github.com/FlaminSarge/tf2attributes/)
 */

#include <sdktools>

#define _X64 1

#if defined _X64
#warning "Using Bottiger's sdktools64 branch, if you are not using it, things are about to explode!"
#include <port64>

public bool IS_NULL_ARRAY(const int[] arr)
{
	return arr[0] == -1 && arr[1] == -1;
}

public bool IS_NULL_ADDRESS(const Address64 arr)
{
	return arr.low == -1 && arr.high == -1;
}
#endif

new const int:NULL_ARRAY[2] = {-1, -1};

Handle hSDKSetRuntimeValue = INVALID_HANDLE;
Handle hSDKGetAttributeDef = INVALID_HANDLE;
Handle hSDKSchema = INVALID_HANDLE;

public void hmmr_attribute_adapter_init() {
	PrintToServer("[hmmr/attribute_adapter] Loading ATTRIBUTE_ADAPTER.");
	Handle hGameConf = LoadGameConfigFile("tf2.hmmr_attributes");
	if (hGameConf == INVALID_HANDLE) {
		SetFailState("[hmmr/weapon_adapter] Failed to find the gamedata config handle!");
		return;
	}

	StartPrepSDKCall(SDKCall_Static);
	PrepSDKCall_SetFromConf(hGameConf, SDKConf_Signature, "GEconItemSchema");
#if defined _X64
	PrepSDKCall_SetReturnInfo(SDKType_Pointer, SDKPass_Plain); // Returns address of CEconItemSchema
#else
	PrepSDKCall_SetReturnInfo(SDKType_PlainOldData, SDKPass_Plain);
#endif
	hSDKSchema = EndPrepSDKCall();
	
	if (hSDKSchema == INVALID_HANDLE)
	{
		SetFailState("[hmmr/attribute_adapter] Failed to hook into GEconItemSchema!")
		return;
	}

	StartPrepSDKCall(SDKCall_Raw);
	PrepSDKCall_SetFromConf(hGameConf, SDKConf_Signature, "CAttributeList::SetRuntimeAttributeValue");
#if defined _X64
	PrepSDKCall_AddParameter(SDKType_Pointer, SDKPass_Plain);
#else
	PrepSDKCall_AddParameter(SDKType_PlainOldData, SDKPass_Plain);
#endif
	PrepSDKCall_AddParameter(SDKType_Float, SDKPass_Plain);
	hSDKSetRuntimeValue = EndPrepSDKCall();
	
	if (hSDKSetRuntimeValue == INVALID_HANDLE)
	{
		SetFailState("[hmmr/attribute_adapter] Failed to hook into CAttributeList::SetRuntimeAttributeValue!")
		return;
	}

	StartPrepSDKCall(SDKCall_Raw);
	PrepSDKCall_SetFromConf(hGameConf, SDKConf_Signature, "CEconItemSchema::GetAttributeDefinition");
	PrepSDKCall_AddParameter(SDKType_PlainOldData, SDKPass_Plain);
#if defined _X64
	PrepSDKCall_SetReturnInfo(SDKType_Pointer, SDKPass_Plain); // Returns address of a CEconItemAttributeDefinition
#else
	PrepSDKCall_SetReturnInfo(SDKType_PlainOldData, SDKPass_Plain);
#endif
	hSDKGetAttributeDef = EndPrepSDKCall();
	
	if (hSDKGetAttributeDef == INVALID_HANDLE)
	{
		SetFailState("[hmmr/attribute_adapter] Failed to hook into CEconItemSchema::GetAttributeDefinition!")
		return;
	}
}

public int SetAttribute(int iEntity, int iDefIndex, float flValue)
{
	if (!IsValidEntity(iEntity)) {
		return -1;
	}

#if defined _X64
	/* WHY IS THIS FUCKING LEGAL AND NOT JUST A DIRECT ASSIGNMENT */
	Address64 pEntAttributeList;
	pEntAttributeList = GetEntityAttributeList(iEntity);

	if (IS_NULL_ADDRESS(pEntAttributeList)) {
#else
	Address pEntAttributeList = GetEntityAttributeList(iEntity);
	if (pEntAttributeList == Address_Null) {
#endif
		PrintToServer("[hmmr/attribute_adapter] SetAttribute(): GetEntityAttributeList returned NULL.");
		return -1;
	}

#if defined _X64
	/* WHY IS THIS FUCKING LEGAL AND NOT JUST A DIRECT ASSIGNMENT */
	Address64 pAttribDef;
	pAttribDef = GetAttributeDefinitionByID(iDefIndex);

	if (IS_NULL_ADDRESS(pAttribDef)) {
#else
	Address pAttribDef = GetAttributeDefinitionByID(iDefIndex);
	if (pAttribDef == Address_Null) {
#endif
		PrintToServer("[hmmr/attribute_adapter] SetAttribute(): GetAttributeDefinitionByID returned NULL.");
		return -1;
	}

	PrintToServer("[hmmr/attribute_adapter] SetAttribute(): iDefIndex=%i, pEntAttributeList=%i, pAttribDef=%i, flValue=%f", iDefIndex, pEntAttributeList, pAttribDef, flValue);

	SDKCall(hSDKSetRuntimeValue, pEntAttributeList, pAttribDef, flValue);
	return 1;
}

#if defined _X64
static Address64 GetItemSchema() {
	int pSchema[2];
	SDKCall(hSDKSchema, pSchema);
	return pSchema;
}
#else
static Address GetItemSchema() {
	return SDKCall(hSDKSchema);
}
#endif

#if defined _X64
static Address64 GetAttributeDefinitionByID(int id) {
	/* WHY IS THIS FUCKING LEGAL AND NOT JUST A DIRECT ASSIGNMENT */
	Address64 pSchema;
	pSchema = GetItemSchema();

	if (IS_NULL_ADDRESS(pSchema))
	{
		return NULL_ARRAY;
	} 
	else
	{
		int pAttr[2];
		SDKCall(hSDKGetAttributeDef, pSchema, pAttr, id);
		return pAttr;
	}
}
#else
static Address GetAttributeDefinitionByID(int id) {
	Address pSchema = GetItemSchema();

	if (pSchema == Address_Null)
	{
		return Address_Null;
	} 
	else
	{
		return SDKCall(hSDKGetAttributeDef, pSchema, id);
	}	
}
#endif

/**
 * Returns the m_AttributeList offset.  This does not correspond to the CUtlVector instance
 * (which is offset by 0x04).
 */
#if defined _X64
static Address64 GetEntityAttributeList(int entity) {
	int offsAttributeList = GetEntSendPropOffs(entity, "m_AttributeList", true);
	if (offsAttributeList != -1)
	{
		Address64 arr;
		Port64_GetEntityAddress(entity, arr);

		Address64 _compat;
		Port64_FromPseudoAddress(view_as<Address>(offsAttributeList), _compat);

		Port64_Add(arr, _compat, arr);

		return arr;
	}
	else
	{
		return NULL_ARRAY;
	}
}
#else
static Address GetEntityAttributeList(int entity) {
	int offsAttributeList = GetEntSendPropOffs(entity, "m_AttributeList", true);
	if (offsAttributeList != -1)
	{
		return GetEntityAddress(entity) + view_as<Address>(offsAttributeList);
	}
	else
	{
		return Address_Null;
	}
}
#endif